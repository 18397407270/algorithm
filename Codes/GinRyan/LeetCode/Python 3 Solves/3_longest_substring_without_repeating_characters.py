'''
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:

输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

示例 2:

输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

示例 3:

输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。


'''

'''
 解题思考1:
 最通用的想法是，按照逐项进行比对是否存在重复项，来获取最长可能
 子串长度，如果这么做，那么妥妥的时间复杂度会是O(n^3).

 解题思考2：
 按照英文字母最长不重复序列来看，英文字母的最长不重复串上界为26
 因此可以使用滑动窗口法判断。滑动窗口第二个字母的起始位置，即已
 经被认为是跟前面的长串存在重复的字母，即下一个子串的开始。遇到
 这种长串时，上一次的最长子串长度计数器被缓存到另一个变量，计数
 器归零重新开始计数。（其中存在比对过程是缓存最新一次的子串长度
 ，如果比对结果并没有超过上一次缓存的最长子串长度，那么抛弃本次
 比对的子串长度，缓存的子串仍然是最长值）
 理论上它的时间复杂度大约为O(n^2)，如果牺牲空间换时间，用哈希映
 射或者说字典存储（字母：位置排序）的哈希表来存储正在检查的滑动
 窗口，可以替换一层查找过程的循环，查找过程从O(n)降低到约O(1)，
 整个滑动窗口比对的过程可以降低到O(n)。

 解题思考3：
 按顺序遍历一次，每项都存入一个字典，每次遇到已存在字符时记录此时
 字典长度，然后清空字典。继续上述过程，第二次以后记录长度时需要比
 对是否大于已有的长度值，如果不大于则忽略这个长度并清空字典，直至
 遍历结束，再进行一次比对字典长度。利用字典/哈希映射和降低时间复
 杂度至O(n)，仅进行一次循环遍历。

 附加：
 是否可以将复杂度降至更低？比如将其降低至O(log n)？暂时没想到方法。
'''
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:

        return 0
    

example = "qaazrrrrwgcewhsozke"
print(Solution().lengthOfLongestSubstring(example))
